name: Go CI

# Grant the workflow permission to write packages so the GITHUB_TOKEN can
# be used to push images to GitHub Container Registry (GHCR).
permissions:
  contents: read
  packages: write

on:
  push:
    branches: [ main, develop, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: go
    steps:
      - uses: actions/checkout@v4
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      - name: Install golangci-lint
        run: |
          # Install golangci-lint into GOPATH/bin for the runner
          go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

      - name: Run golangci-lint
        run: |
          # Use the job's working-directory (defaults.run.working-directory is set to go)
          $(go env GOPATH)/bin/golangci-lint run --timeout=5m ./...
      - name: Run go vet
        run: go vet ./...

  test:
    name: Test
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: go
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v4
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      - name: Cache Go build and modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          # Hash any go.sum in the repository (module is under `go/`) so the
          # cache key resolves whether the file is at repo root or in subfolders.
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Install dependencies
        run: go mod download

      - name: Run tests and produce coverage
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: postgres
          DB_PASSWORD: postgres
          DB_NAME: test_db
          DB_SSL_MODE: disable
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          JWT_SECRET: test-secret
          # Do not start the real server subprocess in this job; the
          # dedicated `integration` job runs integration tests with
          # docker-compose. Running integration tests here caused the
          # runner to hang waiting for subprocess I/O to drain.
          BASE_DOMAIN: localhost
          BASE_URL: http://localhost:8080
          # SendGrid key not used for real sends in CI; provide dummy non-empty value
          SENDGRID_API_KEY: test-sendgrid-key
        run: |
          mkdir -p coverage
          # Run all packages except the integration test package which is
          # executed in the separate `integration` job (docker-compose).
          PACKAGES=$(go list ./... | grep -v '/test/integration')
          echo "Running tests for packages: $PACKAGES"
          go test -v -race -covermode=atomic -coverprofile=coverage/cover.out $PACKAGES

      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: go-coverage
          path: go/coverage/cover.out

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: go/coverage/cover.out

      - name: Show coverage summary
        run: |
          go tool cover -func=coverage/cover.out | sed -n '1,200p'

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [lint, test]
    defaults:
      run:
        working-directory: go
    steps:
      - uses: actions/checkout@v4
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      - name: Build
        run: go build -v ./cmd/server

  docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [build]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha
            type=raw,value=latest,enable={{is_default_branch}}
      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          # Build from the go/ directory where the Dockerfile and app live
          context: ./go
          file: ./go/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: [docker]
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Deploy to production
        run: |
          echo "Deployment would happen here"
  integration:
    name: Integration Tests (docker-compose)
    runs-on: ubuntu-latest
    needs: [test]
    defaults:
      run:
        working-directory: go
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and start docker-compose
        run: |
          # Prepare a runtime .env for docker-compose from the checked-in
          # .env.example. We don't commit .env to the repository, but
          # docker-compose requires an env file during CI runs.
          cp .env.example .env || true
          # Ensure service hostnames are correct for compose network
          sed -i 's/^DB_HOST=.*/DB_HOST=db/' .env || echo 'DB_HOST=db' >> .env
          sed -i 's/^REDIS_HOST=.*/REDIS_HOST=redis/' .env || echo 'REDIS_HOST=redis' >> .env
          # Ensure TLS vars are empty in CI so the server runs HTTP when no certs are provided
          sed -i 's/^TLS_CERT_FILE=.*/TLS_CERT_FILE=/' .env || echo 'TLS_CERT_FILE=' >> .env
          sed -i 's/^TLS_KEY_FILE=.*/TLS_KEY_FILE=/' .env || echo 'TLS_KEY_FILE=' >> .env
          # Show the CI-only compose config so we can verify there is no
          # dev host bind for the app service.
          echo "--- effective CI compose config ---"
          docker compose -f docker-compose.ci.yml config || true

          # Build the app image explicitly so we can inspect it before
          # docker-compose attempts to start containers.
          docker build -f Dockerfile -t go-app:ci .
          echo "--- image /app contents ---"
          docker run --rm go-app:ci ls -la /app || true
          echo "--- image /app/bin contents ---"
          docker run --rm go-app:ci ls -la /app/bin || true

          # Now start the CI-only compose (no host bind mounts).
          # Capture output; if it fails we'll collect extra diagnostics.
          if ! docker compose -f docker-compose.ci.yml up -d; then
            echo "docker compose up failed; collecting diagnostics..."
            echo "--- effective CI compose config (again) ---"
            docker compose -f docker-compose.ci.yml config || true
            echo "--- docker images ---"
            docker images || true
            echo "--- docker volumes ---"
            docker volume ls || true
            echo "--- docker ps -a (recent containers) ---"
            docker ps -a --no-trunc --format 'table {{.ID}}	{{.Image}}	{{.Names}}	{{.Status}}' || true
            # Inspect any containers created from the built image to see mounts
            CONTAINERS=$(docker ps -a --filter ancestor=go-app:ci -q)
            if [ -n "$CONTAINERS" ]; then
              for c in $CONTAINERS; do
                echo "--- inspect container $c Mounts ---"
                docker inspect --format '{{json .Mounts}}' $c || true
              done
            fi
            exit 1
          fi

      - name: Wait for app health
        run: |
          echo "Waiting for app at http://localhost:8080/health..."
          for i in $(seq 1 60); do
            status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health || true)
            if [ "$status" = "200" ]; then
              echo "app healthy"
              exit 0
            fi
            sleep 1
          done
          echo "App did not become healthy in time"
          docker compose -f docker-compose.ci.yml logs --no-color app || true
          docker compose -f docker-compose.ci.yml ps
          exit 1

      - name: Run integration tests
        env:
          TEST_SERVER_URL: http://localhost:8080
          SENDGRID_API_KEY: test-sendgrid-key
        run: |
          go test -v ./test/integration

      - name: Tear down docker-compose
        if: always()
        run: |
          docker compose -f docker-compose.ci.yml down -v
